export function mergeAddonsIfUpdated(existingAddons, newAddons) {
    const newEntries = Object.entries(newAddons);
    const result = { ...existingAddons };
    let updated = newEntries.length !== Object.keys(existingAddons).length;
    for (const [key, value] of newEntries) {
        if (!(key in result) || result[key] == null) {
            updated = true;
            result[key] = value;
            continue;
        }
        if (value == null) {
            continue;
        }
        if (Array.isArray(result[key])) {
            if (!Array.isArray(value)) {
                return new Error("Mismatched merging addons (Array.isArray).");
            }
            const existingElementKeys = new Set(result[key].map(createKey));
            for (const newElement of value) {
                const newElementKey = createKey(newElement);
                if (!existingElementKeys.has(newElementKey)) {
                    existingElementKeys.add(newElementKey);
                    result[key].push(newElement);
                    updated = true;
                }
            }
            continue;
        }
        if (typeof result[key] === "object") {
            if (typeof value !== "object") {
                return new Error("Mismatched merging addons (typeof object).");
            }
            const nestedMerge = mergeAddonsIfUpdated(result[key], value);
            if (nestedMerge) {
                if (nestedMerge instanceof Error) {
                    return nestedMerge;
                }
                result[key] = nestedMerge;
                updated = true;
            }
            continue;
        }
        if (result[key] !== value) {
            return new Error(`Mismatched merging addons (${result[key]} vs. ${value}).`);
        }
    }
    return updated ? result : undefined;
}
// TODO: In the future, this could be a more quick and intelligent hash...
function createKey(value) {
    return JSON.stringify(value);
}
//# sourceMappingURL=mergeAddonsIfUpdated.js.map